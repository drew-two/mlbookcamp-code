Transcription of [[course-zoomcamp/03-classification/notes/notebook#3 8 One-hot encoding]]
# 3.8 One-hot encoding

* Use Scikit-Learn to encode categorical features

Say we have 7 examples for 2 variables that we want to one-hot encode:

| Gender | Contract |
|--------|----------|
| F      | 2Y       |
| F      | 1Y       |
| M      | M        |
| M      | 1Y       |
| F      | 1Y       |
| M      | M        |
| M      | 2Y       |

So Gender can be F or M, Contract can be M, 1Y or 2Y.

We would convert this to:

![One-Hot Encoding](./images/one-hot-encoding.png)

The values with 1 are 'hot', or on; values with 0 are 'cold', or off. Terminology comes from electronics (hot circuit is on)

In Scikit-learn we will use DictVectorizer.

```python
from sklearn.feature_extraction import DictVectorizer
```

Lets take a look at two categorical variables

```python
df_train[['gender', 'contract']].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>gender</th>
      <th>contract</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>female</td>
      <td>two_year</td>
    </tr>
    <tr>
      <th>1</th>
      <td>male</td>
      <td>month-to-month</td>
    </tr>
    <tr>
      <th>2</th>
      <td>female</td>
      <td>month-to-month</td>
    </tr>
    <tr>
      <th>3</th>
      <td>female</td>
      <td>month-to-month</td>
    </tr>
    <tr>
      <th>4</th>
      <td>female</td>
      <td>two_year</td>
    </tr>
  </tbody>
</table>
</div>



We want to turn this into a dictionary. Lets use the first 10, oriented by records (row-wise as opposed to column-wise).

```python
dicts = df_train[['gender', 'contract']].iloc[:100].to_dict(orient='records')
dicts
```




    [{'gender': 'female', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'one_year'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'two_year'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'one_year'},
     {'gender': 'female', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'one_year'},
     {'gender': 'female', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'one_year'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'one_year'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'two_year'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'one_year'},
     {'gender': 'female', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'two_year'},
     {'gender': 'male', 'contract': 'one_year'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'one_year'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'one_year'},
     {'gender': 'female', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'month-to-month'},
     {'gender': 'male', 'contract': 'one_year'},
     {'gender': 'male', 'contract': 'month-to-month'}]



Dict Vectorizer will infer sparsity as one-hot encoding leaves a lot of zeroes. This could be useful but we do not want it right now.

```python
dv = DictVectorizer(sparse=False)
```

Dict Vectorizer will infer (from 'training') the columns needed.

```python
dv.fit(dicts)
```




    DictVectorizer(sparse=False)



Let's see how the columns are organized. 

```python
dv.get_feature_names()
```

    /home/andre/anaconda3/envs/exp-tracking-env/lib/python3.9/site-packages/sklearn/utils/deprecation.py:87: FutureWarning: Function get_feature_names is deprecated; get_feature_names is deprecated in 1.0 and will be removed in 1.2. Please use get_feature_names_out instead.
      warnings.warn(msg, category=FutureWarning)





    ['contract=month-to-month',
     'contract=one_year',
     'contract=two_year',
     'gender=female',
     'gender=male']



Above we see the columns created. Let's see how they are represented in the data: 

```python
dv.transform(dicts)
```




    array([[0., 0., 1., 1., 0.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 1., 0.],
           [0., 0., 1., 1., 0.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 1., 0.],
           [0., 0., 1., 1., 0.],
           [1., 0., 0., 1., 0.],
           [0., 0., 1., 1., 0.],
           [1., 0., 0., 0., 1.],
           [0., 0., 1., 1., 0.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [0., 0., 1., 1., 0.],
           [1., 0., 0., 1., 0.],
           [0., 1., 0., 0., 1.],
           [0., 0., 1., 0., 1.],
           [1., 0., 0., 0., 1.],
           [0., 1., 0., 1., 0.],
           [1., 0., 0., 1., 0.],
           [0., 0., 1., 1., 0.],
           [1., 0., 0., 0., 1.],
           [0., 0., 1., 0., 1.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 1., 0.],
           [0., 1., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 0., 1.],
           [0., 1., 0., 1., 0.],
           [0., 1., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [0., 1., 0., 1., 0.],
           [0., 1., 0., 1., 0.],
           [0., 0., 1., 0., 1.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 0., 1.],
           [0., 1., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [0., 0., 1., 1., 0.],
           [1., 0., 0., 0., 1.],
           [0., 0., 1., 1., 0.],
           [0., 0., 1., 0., 1.],
           [1., 0., 0., 0., 1.],
           [0., 1., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [0., 1., 0., 1., 0.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [0., 1., 0., 0., 1.],
           [0., 0., 1., 1., 0.],
           [0., 0., 1., 1., 0.],
           [0., 0., 1., 0., 1.],
           [0., 0., 1., 1., 0.],
           [1., 0., 0., 0., 1.],
           [0., 0., 1., 1., 0.],
           [1., 0., 0., 0., 1.],
           [0., 1., 0., 0., 1.],
           [0., 1., 0., 0., 1.],
           [0., 0., 1., 0., 1.],
           [0., 1., 0., 0., 1.],
           [0., 1., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 1., 0.],
           [0., 0., 1., 0., 1.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 1., 0.],
           [0., 0., 1., 1., 0.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 0., 1.],
           [0., 1., 0., 1., 0.],
           [0., 1., 0., 0., 1.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [0., 1., 0., 1., 0.],
           [0., 0., 1., 0., 1.],
           [0., 1., 0., 0., 1.],
           [1., 0., 0., 1., 0.],
           [0., 1., 0., 0., 1.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [1., 0., 0., 1., 0.],
           [0., 1., 0., 0., 1.],
           [1., 0., 0., 1., 0.],
           [1., 0., 0., 0., 1.],
           [0., 1., 0., 0., 1.],
           [1., 0., 0., 0., 1.]])



First three are for contract, last two are for gender (exactly as seen from .get_feature_names())

For continuous numerical variables, dict vectorizer adds these directly (no one-hot encoding).

Now let's do this for all categorical and numerical variables:

```python
train_dict = df_train[categorical + numerical].to_dict(orient='records')
train_dict[0]
```




    {'gender': 'female',
     'seniorcitizen': 0,
     'partner': 'yes',
     'dependents': 'yes',
     'phoneservice': 'yes',
     'multiplelines': 'yes',
     'internetservice': 'fiber_optic',
     'onlinesecurity': 'yes',
     'onlinebackup': 'yes',
     'deviceprotection': 'yes',
     'techsupport': 'yes',
     'streamingtv': 'yes',
     'streamingmovies': 'yes',
     'contract': 'two_year',
     'paperlessbilling': 'yes',
     'paymentmethod': 'electronic_check',
     'tenure': 72,
     'monthlycharges': 115.5,
     'totalcharges': 8425.15}



Now, make new Dict Vectorizer and fit this on all categorical + numerical variables in the training data:

```python
dv = DictVectorizer(sparse=False)

train_dict = df_train[categorical + numerical].to_dict(orient='records')
X_train = dv.fit_transform(train_dict)

# Do NOT fit on validation dataset. Consider this like simulated production data. Only apply transformations you can do online
val_dict = df_val[categorical + numerical].to_dict(orient='records')
X_val = dv.transform(val_dict)
```

```python
dv.get_feature_names()
```

    /home/andre/anaconda3/envs/exp-tracking-env/lib/python3.9/site-packages/sklearn/utils/deprecation.py:87: FutureWarning: Function get_feature_names is deprecated; get_feature_names is deprecated in 1.0 and will be removed in 1.2. Please use get_feature_names_out instead.
      warnings.warn(msg, category=FutureWarning)





    ['contract=month-to-month',
     'contract=one_year',
     'contract=two_year',
     'dependents=no',
     'dependents=yes',
     'deviceprotection=no',
     'deviceprotection=no_internet_service',
     'deviceprotection=yes',
     'gender=female',
     'gender=male',
     'internetservice=dsl',
     'internetservice=fiber_optic',
     'internetservice=no',
     'monthlycharges',
     'multiplelines=no',
     'multiplelines=no_phone_service',
     'multiplelines=yes',
     'onlinebackup=no',
     'onlinebackup=no_internet_service',
     'onlinebackup=yes',
     'onlinesecurity=no',
     'onlinesecurity=no_internet_service',
     'onlinesecurity=yes',
     'paperlessbilling=no',
     'paperlessbilling=yes',
     'partner=no',
     'partner=yes',
     'paymentmethod=bank_transfer_(automatic)',
     'paymentmethod=credit_card_(automatic)',
     'paymentmethod=electronic_check',
     'paymentmethod=mailed_check',
     'phoneservice=no',
     'phoneservice=yes',
     'seniorcitizen',
     'streamingmovies=no',
     'streamingmovies=no_internet_service',
     'streamingmovies=yes',
     'streamingtv=no',
     'streamingtv=no_internet_service',
     'streamingtv=yes',
     'techsupport=no',
     'techsupport=no_internet_service',
     'techsupport=yes',
     'tenure',
     'totalcharges']



We can see each categorical variable has been split up for each possible value.

Let's see how one example is encoded by the fitted training variables:

```python
list(X_train[:5][0])
```




    [0.0,
     0.0,
     1.0,
     0.0,
     1.0,
     0.0,
     0.0,
     1.0,
     1.0,
     0.0,
     0.0,
     1.0,
     0.0,
     115.5,
     0.0,
     0.0,
     1.0,
     0.0,
     0.0,
     1.0,
     0.0,
     0.0,
     1.0,
     0.0,
     1.0,
     0.0,
     1.0,
     0.0,
     0.0,
     1.0,
     0.0,
     0.0,
     1.0,
     0.0,
     0.0,
     0.0,
     1.0,
     0.0,
     0.0,
     1.0,
     0.0,
     0.0,
     1.0,
     72.0,
     8425.15]
